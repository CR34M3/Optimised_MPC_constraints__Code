#!/usr/bin/env python
"""
Class definitions for constraint set
Author: Andre Campher
"""
# Dependencies: - convertfuns
#               - auxfuns
#               - SciPy

from auxfuns import qhull, mat2ab
from convertfuns import vert2con, con2vert
from scipy import empty, vstack, dot, tile, all, zeros, sqrt, ones, c_, sign
from scipy import linalg
from scipy import all as sciall

class ConSet:
    """
    Class for constraint sets. Generated by either a constraint set [A s b] or
    by a set of vertices [v].
    """
    def __init__(self, *inargs):
        if len(inargs) == 1:
            self.vert = inargs[0]
            self.A, self.s, self.b = vert2con(self.vert)
            self.closed = True
        elif len(inargs) == 3:
            if all(sign(inargs[1]) == -1):  # ensure an all -1 sign vector
                self.A, self.s, self.b = inargs
            else:
                self.A, self.s, self.b = mat2ab(c_[inargs])                
            self.vert, self.closed = con2vert(self.A, self.b)
        else:
            exit(1)  # TODO: Raise exception
        self.nd = self.A.shape[1]
        
    def vol(self):
        """Return 'volume' of feasible region."""
        return qhull(self.vert,"FS")
        
    def outconlin(self, model):
        """Convert constraints to output space using a linear model"""       
        # calc AOS (from G and AIS)
        outverttemp = empty([1, self.vert.shape[1]])
        for v in self.vert:
            x = model*v.transpose()
            outverttemp = vstack((outverttemp, x.transpose()))
        #remove first line of junk data from outverttemp and convert
        return vert2con(outverttemp[1:, :]) 
    
    def intersect(self, conset2):
        """Determine intersection between current constraint set and another"""
        combA = vstack((self.A, conset2.A))
        combb = vstack((self.b, conset2.b))
        intcombvert = con2vert(combA, combb)[0]
        return vert2con(intcombvert)
    
    def allinside(self, conset2):
        """
        Determine if all vertices of self is within conset2. allvinside merely
        returns True/False whereas insidenorm returns a measure of 'inside-ness'
        better suited for optimisers.
        """
        # Inside check
        Av = dot(conset2.A, self.vert.T)
        bv = tile(conset2.b, (1, self.vert.shape[0]))
        eps = 1e-13
        intmpvals = Av - bv
        intmp = intmpvals <= eps
        allvinside = sciall(intmp)
        # Inside norm
        # insidenorm = array([[con1in,con1out],[con2in,con2out]...])
        insidenorm = zeros((Av.shape[0], 1))
        for cons in range(Av.shape[0]):
            for verts in range(Av.shape[1]):
                dist = abs(intmpvals[cons, verts])/sqrt(sum(conset2.A[cons, :]**2))
                if not intmp[cons, verts]:  # outside
                    insidenorm[cons] = insidenorm[cons] - dist
        # Outside volume
#        outsidevol = self.vol() - ConSet(*self.intersect(conset2)).vol()
        return allvinside, insidenorm#, outsidevol
    
if __name__ == "__main__":
    from scipy import array
    from pylab import plot, show, legend
    
    v = array([[0, 0], [0, 10], [10, 10], [10, 0]])
    initcset = ConSet(v)
    vp = vstack([v, v[0, :]])
    plot(vp[:, 0], vp[:, 1], 'b', linewidth=3)

    v2 = array([[1., 1], [10, 0], [10, 10], [0, 10]])
    set2 = ConSet(v2)
    vp2 = vstack([v2, v2[0, :]])
    plot(vp2[:, 0], vp2[:, 1], 'r', linewidth=3)

    print set2.allinside(initcset)

    set3 = ConSet(*set2.intersect(initcset))
    vp3 = vstack([set3.vert, set3.vert[0, :]])
    plot(vp3[:, 0], vp3[:, 1], 'g', linewidth=3)
    show()
    

#TODO: Memoize volume calculation
#TODO: Add support for non-square systems
