#!/usr/bin/env python
"""
Class definitions for constraint set
Author: Andre Campher
"""
# Dependencies: - convertfuns
#               - auxfuns
#               - SciPy

from auxfuns import qhull, mat2ab, uniqm, splitAb
from convertfuns import vert2con, con2vert
from scipy import empty, vstack, dot, tile, all, zeros, sqrt, sum, c_, sign
from scipy import mat, ones, linalg, array
from scipy import all as sciall
import numpy

class ConSet:
    """
    Class for constraint sets. Generated by either a constraint set [A s b] or
    by a set of vertices [v].
    """
    def __init__(self, *inargs):
        if len(inargs) == 1:
            self.vert = inargs[0]
            self.A, self.s, self.b = vert2con(self.vert)
            self.closed = True
        elif len(inargs) == 3:
            if all(sign(inargs[1]) == -1):  # ensure an all -1 sign vector
                self.A, self.s, self.b = inargs
            else:
                self.A, self.s, self.b = mat2ab(c_[inargs])         
            self.vert, self.closed = con2vert(self.A, self.b)
        else:
            exit(1)  # TODO: Raise exception
        self.nd = self.A.shape[1]
        self.cscent = sum(self.vert, axis=0)/len(self.vert)
        
    def vol(self):
        """Return 'volume' of feasible region."""
        return qhull(self.vert,"FS")

    def oi(self, conset2):
        """
        Return the Operabilty Index (Vinson, 2000) of the set, where conset2 
        is equivalent to the DOS
        """
        Vint = ConSet(*self.intersect(conset2)).vol()
        return Vint/conset2.vol()
        
    def outconlin(self, model, ss):
        """Convert constraints to another space using a linear model"""       
        # e.g. calc AOS (from G and AIS)
        outverttemp = empty([1, self.vert.shape[1]])
        # first center 'input'-space around [0]
        inverttemp = self.vert - self.cscent
        for v in inverttemp:
            x = model*v.transpose()
            outverttemp = vstack((outverttemp, x.transpose()))
        #remove first line of junk data from outverttemp and convert
        outverttemp = outverttemp + ss
        return vert2con(outverttemp[1:, :]) 
    
    def intersect(self, conset2):
        """Determine intersection between current constraint set and another"""
        def remredcons(A, b, verts):
            """Reduce a constraint set by removing unnecessary constraints."""
            eps = 10e-9
            #1 Co-planar constraints;
            #  Remove as not to affect 3rd check
            Ab = c_[A, b]
            Abnorms = ones((Ab.shape[0], 1))
            for i in range(Ab.shape[0]):
                Abnorms[i] = linalg.norm(Ab[i, :])
            Abn = Ab/Abnorms
            Abkeep = ones((0, Ab.shape[1]))
            Abtest = ones((0, Ab.shape[1]))
            for r1 in range(Abn.shape[0]):
                noocc = ones((1, 0))
                for r2 in range(Abn.shape[0]):
                    #print abs(Abn[r1, :] - Abn[r2, :])
                    if numpy.all(abs(Abn[r1, :] - Abn[r2, :]) < eps):
                        noocc = c_[noocc, r2]
                if noocc.size == 1:
                    Abtest = vstack([Abtest, Ab[r1, :]])
                else:
                    Abkeep = vstack([Abkeep, Ab[r1, :]])
            if Abkeep.shape[0] > 1:
                Abkeep = uniqm(Abkeep, eps)
            #2 Vert subset satisfying; no action needed (redundancy uncertain)
            #3 All vert satisfying constraints;
            A, b = splitAb(array(Abtest).ravel(), verts.shape[1])
            keepA = ones((0, A.shape[1]))
            keepb = ones((0, 1))
            bt = tile(b, (1, verts.shape[0]))
            k = mat(A)*mat(verts.T) - bt
            kk = sum(k > eps, axis=1)
            for i in range(len(kk)):
                if kk[i] != 0:
                    keepA = vstack([keepA, A[i, :]])
                    keepb = vstack([keepb, b[i, :]])
            outAb = vstack([c_[keepA, keepb], Abkeep])
            return splitAb(outAb.ravel(), verts.shape[1])
        #Combine constraints and vertices
        combA = vstack((self.A, conset2.A))
        combb = vstack((self.b, conset2.b))
        combv = vstack((self.vert, conset2.vert))
        #Remove redundant constraints
        ncombA, ncombb = remredcons(combA, combb, combv)
        #Calc and return intersection
        intcombvert = con2vert(combA, combb)[0]
        return intcombvert
    
    def allinside(self, conset2):
        """
        Determine if all vertices of self is within conset2. allvinside merely
        returns True/False whereas insidenorm returns a measure of 'inside-ness'
        better suited for optimisers.
        """
        # Inside check
        Av = dot(conset2.A, self.vert.T)
        bv = tile(conset2.b, (1, self.vert.shape[0]))
        eps = 1e-13
        intmpvals = Av - bv
        intmp = intmpvals <= eps
        allvinside = sciall(intmp)
        # Inside norm
        insidenorm = zeros((Av.shape[0], 1))
        for cons in range(Av.shape[0]):
            for verts in range(Av.shape[1]):
                dist = abs(intmpvals[cons, verts])/sqrt(sum(conset2.A[cons, :]**2))
                if not intmp[cons, verts]:  # outside
                    insidenorm[cons] = insidenorm[cons] - dist
        # Outside volume
        return allvinside, insidenorm#, outsidevol